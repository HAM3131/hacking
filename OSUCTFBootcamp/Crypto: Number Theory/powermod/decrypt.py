# You need a library called PyCryptodome to run this!
# You can install it like so: `pip3 install pycryptodome`
import Crypto.Util.number as cun

# In RSA, this is called the modulus.
# It's the product of two randomly generated large primes.
n = 18672326372778055603800441956370607392898760061149247937609570330090609637690203426847361343557717521603407449524491498664742876654351128628865190151467416543190015718073486512073412892554191500567332365123197979644844552876585610096844372929225810574792420982410718994809647398467399234537010914829629939705415709790222230980188485332847853358643536719838169005620783871987945458908685093761133376143866255285640091472892019118825446436188840243964839160493718228441347664346044858946766745424031532750985662660448533207532415856199796279597950658378791110095139678906560174200531167941565487053338337472040657425293

# This is the private key. I found this on my friend's computer :)
d = 6153545401822793916884842842572781458898445455249728503845026473431755908186719160368178438106101637725107864180996496454844082731597047105089192012014484375235637265650718856337054971289278240219314958297310373748712218335115980390796721951346858366943355789525103511755172871997480639448408711697061925900660598237514987007955548056992117709357399984483076456959853986443449423427760895203908712852065064310635646153515817514916447120478733912387382805037244894516516694277913094134836762242534457665441424136219559608815517214544583744356396051142262778340303679898298201905973436579341549743051009466080402548033

# This is his encrypted message represented as an integer.
ciphertext = 18483409786245106444085746987927057135321638455844253482333670262012576475551619737265826388909195091539625585603760699764553316450961638455282218897036709041442209136570193049445336276684226112904826687056786547653245053406061895368165924645914776115315425872965791225657949656603555230865803403029308319966046535022358235228688938895340606520770108326185121981331585646755452596538505570122682506412382598689485184270682604863835226672242202188833646342225883463374591035669358459011540480698000921566398552026583448640867089130786804487524272071812028006577396906322521345863021863114265294070229093116827814661445

# I read on Wikipedia that this is how you decrypt the ciphertext. But why is
# it taking so long? Is there some faster way to do modular exponentiation in
# Python that I'm missing?
print("Starting decryption...")
plaintext = pow(ciphertext, d, n)
print("Done!")

print(cun.long_to_bytes(plaintext))
