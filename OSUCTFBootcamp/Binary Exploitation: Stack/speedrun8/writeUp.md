# Reconnaissance
## C Review
The program interestingly has a variable defined globally called `key`, with a long string held in it. Interesting. Lets look at the main function. The program takes a user input into a 50 byte buffer, then performs a string comparison on each byte of that buffer with the corresponding byte of the `key` variable mentioned above, XORed with 0x27. If any byte doesn't match, the process exits, and if they all match, we get a shell.

Because the c file we were given happens to contain the real key, I initially approached this challenge from the perspective of simply finding what my input should be by performing the XOR myself. However, after completing the challenge and reading `eritque0arcus`'s writeup, I learned about `Angr` and tried again while implementing their method.

# Script
The program is going to consist of two main chunks, first one applying `Angr` to find the necessary starting conditions to get a shell, then our execution of sending that package with `pwn`.

First, we will set up an `Angr` project:
```{python}
import angr
import sys
from pwn import *

path_to_binary = "./challenge/chall_8"
project = angr.Project(path_to_binary)
initial_state = project.factory.entry_state()
simulation = project.factory.simgr(initial_state)

good_address = 0x400924 
simulation.explore(find=good_address)
solution = b''

if simulation.found:
    solution_state = simulation.found[0]
    solution = solution_state.posix.dumps(sys.stdin.fileno())
    print(solution)
else:
    raise Exception('Could not find the solution')
```
We are performing all of our imports at the top, then we start by defining some variables for `Angr`. First we set up a project, and then a simulation manager. These are all just setup steps to be able to run an exploration simulation and find what our starting state must be to reach our destination. `good_address` is the destination address in the file which we want to run, so in this case it is the line of c calling `system("/bin/sh")`. `Angr` will try to explore comparison functions to create a symbolic representation of the program flow, and it will learn what path needs to be taken through the program flow to reach the point we give. This address was found using `Ghidra`.

After the solution is run, we make a simple check if the solution is found or not. If it isn't, an exception is raised, and if it is, we need to extract it from `Angr`'s representation of a solution. The line:
```{python}
solution = solution_state.posix.dumps(sys.stdin.fileno())
```
Is what does this, extracting the binary value for the necessary input to reach our destination in the program flow.

Now, lets use `pwn` to send the solution found above and get a shell.
```{python}
EXE = ELF("./challenge/chall_8")
context.binary = EXE
context.log_level = "DEBUG"

def conn(useExe=False):
	if useExe:
		# r = gdb.debug(EXE.path, "\n".join(breakpoints))
		r = process([EXE.path])
	else:
		r = remote('pwn.osucyber.club',13379)
	return r

io = conn(False)

io.sendline(solution)
io.interactive()

io.close()
```

If this spawns a terminal, then our code worked! We can run it again on the server then call `ls` and `cat flag.txt` in the interactive shell!